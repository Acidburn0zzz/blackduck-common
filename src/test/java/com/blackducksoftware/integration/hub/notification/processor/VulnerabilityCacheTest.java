/*
 * Copyright (C) 2016 Black Duck Software Inc.
 * http://www.blackducksoftware.com/
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Black Duck Software ("Confidential Information"). You shall not
 * disclose such Confidential Information and shall use it only in
 * accordance with the terms of the license agreement you entered into
 * with Black Duck Software.
 */
package com.blackducksoftware.integration.hub.notification.processor;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.joda.time.DateTime;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import com.blackducksoftware.integration.hub.api.component.version.ComponentVersion;
import com.blackducksoftware.integration.hub.api.item.MetaService;
import com.blackducksoftware.integration.hub.api.notification.VulnerabilitySourceQualifiedId;
import com.blackducksoftware.integration.hub.api.vulnerability.VulnerabilityItem;
import com.blackducksoftware.integration.hub.api.vulnerability.VulnerabilityRequestService;
import com.blackducksoftware.integration.hub.dataservice.notification.item.VulnerabilityContentItem;
import com.blackducksoftware.integration.hub.notification.processor.event.NotificationEvent;
import com.blackducksoftware.integration.hub.notification.processor.event.VulnerabilityEvent;
import com.blackducksoftware.integration.hub.rest.RestConnection;
import com.blackducksoftware.integration.hub.service.HubRequestService;
import com.blackducksoftware.integration.hub.service.HubServicesFactory;
import com.blackducksoftware.integration.log.IntBufferedLogger;
import com.blackducksoftware.integration.log.IntLogger;

public class VulnerabilityCacheTest {
    private final EventTestUtil testUtil = new EventTestUtil();

    private VulnerabilityEvent addEvent;

    private VulnerabilityEvent updateEvent;

    private VulnerabilityEvent deletedEvent;

    private VulnerabilityEvent secondaryEvent;

    private List<VulnerabilityItem> vulnerabilityList;

    private MetaService metaService;

    private VulnerabilityCache createCache(List<VulnerabilityItem> vulnerabilityList) throws Exception {
        final RestConnection restConnection = new MockRestConnection();
        final HubServicesFactory factory = new HubServicesFactory(restConnection);
        final IntLogger logger = new IntBufferedLogger();
        metaService = factory.createMetaService(logger);
        final ComponentVersion compVersion = Mockito.mock(ComponentVersion.class);
        Mockito.when(compVersion.getJson()).thenReturn(createComponentJson());
        final VulnerabilityRequestService vulnerabilityRequestService = Mockito.mock(VulnerabilityRequestService.class);
        final HubRequestService hubRequestService = Mockito.mock(HubRequestService.class);
        Mockito.when(hubRequestService.getItem(Mockito.anyString(), Mockito.eq(ComponentVersion.class))).thenReturn(compVersion);
        Mockito.when(vulnerabilityRequestService.getComponentVersionVulnerabilities(Mockito.anyString())).thenReturn(vulnerabilityList);
        final VulnerabilityCache cache = new VulnerabilityCache(hubRequestService, vulnerabilityRequestService, metaService);
        return cache;
    }

    private String createComponentJson() {
        return "{ \"_meta\": { \"href\": \"" + EventTestUtil.COMPONENT_VERSION_URL + "\","
                + "\"links\": [ {"
                + "\rel: \"vulnerabilities\","
                + " \"href\": \"" + EventTestUtil.COMPONENT_VERSION_URL + "\"},{"
                + "\rel\":\"vulnerable-components\","
                + "\"href\": \"" + EventTestUtil.COMPONENT_VERSION_URL + "\""
                + "}]}}";
    }

    @Before
    public void initTest() throws Exception {
        DateTime dateTime = new DateTime();

        final List<VulnerabilitySourceQualifiedId> resultVulnList = new ArrayList<>(2);
        resultVulnList.add(new VulnerabilitySourceQualifiedId(EventTestUtil.VULN_SOURCE, EventTestUtil.HIGH_VULN_ID));
        resultVulnList.add(new VulnerabilitySourceQualifiedId(EventTestUtil.VULN_SOURCE, EventTestUtil.MEDIUM_VULN_ID));
        vulnerabilityList = testUtil.createVulnerabiltyItemList(resultVulnList);

        final List<VulnerabilitySourceQualifiedId> added = new ArrayList<>(3);
        added.add(new VulnerabilitySourceQualifiedId(EventTestUtil.VULN_SOURCE, EventTestUtil.HIGH_VULN_ID));
        added.add(new VulnerabilitySourceQualifiedId(EventTestUtil.VULN_SOURCE, EventTestUtil.MEDIUM_VULN_ID));
        added.add(new VulnerabilitySourceQualifiedId(EventTestUtil.VULN_SOURCE, EventTestUtil.LOW_VULN_ID));

        final List<VulnerabilitySourceQualifiedId> updated = new ArrayList<>(4);
        updated.add(new VulnerabilitySourceQualifiedId(EventTestUtil.VULN_SOURCE, EventTestUtil.HIGH_VULN_ID));
        updated.add(new VulnerabilitySourceQualifiedId(EventTestUtil.VULN_SOURCE, EventTestUtil.MEDIUM_VULN_ID2));
        updated.add(new VulnerabilitySourceQualifiedId(EventTestUtil.VULN_SOURCE, EventTestUtil.LOW_VULN_ID2));
        updated.add(new VulnerabilitySourceQualifiedId(EventTestUtil.VULN_SOURCE, EventTestUtil.LOW_VULN_ID1));

        final List<VulnerabilitySourceQualifiedId> deleted = new ArrayList<>(3);

        deleted.add(new VulnerabilitySourceQualifiedId(EventTestUtil.VULN_SOURCE, EventTestUtil.LOW_VULN_ID));
        deleted.add(new VulnerabilitySourceQualifiedId(EventTestUtil.VULN_SOURCE, EventTestUtil.LOW_VULN_ID2));
        deleted.add(new VulnerabilitySourceQualifiedId(EventTestUtil.VULN_SOURCE, EventTestUtil.LOW_VULN_ID1));
        dateTime = dateTime.plusSeconds(1);
        final VulnerabilityContentItem vulnerability = testUtil.createVulnerability(dateTime.toDate(), EventTestUtil.PROJECT_NAME,
                EventTestUtil.PROJECT_VERSION_NAME, EventTestUtil.COMPONENT, EventTestUtil.VERSION, added, updated, deleted);

        addEvent = new VulnerabilityEvent(ProcessingActionEnum.ADD, NotificationCategoryEnum.VULNERABILITY, vulnerability,
                getVulnerabilityIds(added));
        updateEvent = new VulnerabilityEvent(ProcessingActionEnum.ADD, NotificationCategoryEnum.VULNERABILITY, vulnerability,
                getVulnerabilityIds(updated));
        deletedEvent = new VulnerabilityEvent(ProcessingActionEnum.REMOVE, NotificationCategoryEnum.VULNERABILITY, vulnerability,
                getVulnerabilityIds(deleted));

        final VulnerabilityContentItem vulnerability2 = testUtil.createVulnerability(dateTime.toDate(), EventTestUtil.PROJECT_NAME2,
                EventTestUtil.PROJECT_VERSION_NAME2, EventTestUtil.COMPONENT2, EventTestUtil.VERSION2, added, updated, deleted);

        secondaryEvent = new VulnerabilityEvent(ProcessingActionEnum.ADD, NotificationCategoryEnum.VULNERABILITY, vulnerability2,
                getVulnerabilityIds(added));

    }

    private Set<String> getVulnerabilityIds(final List<VulnerabilitySourceQualifiedId> itemList) {
        final Set<String> set = new HashSet<>();
        for (final VulnerabilitySourceQualifiedId item : itemList) {
            set.add(item.getVulnerabilityId());
        }

        return set;
    }

    @Test
    public void testEventAdd() throws Exception {
        final VulnerabilityCache cache = createCache(vulnerabilityList);
        cache.addEvent(addEvent);
        cache.addEvent(secondaryEvent);
        final Collection<VulnerabilityEvent> eventCollection = cache.getEvents();
        assertFalse(eventCollection.isEmpty());
    }

    @Test
    public void testEventRemove() throws Exception {
        final VulnerabilityCache cache = createCache(vulnerabilityList);
        cache.addEvent(addEvent);
        cache.addEvent(secondaryEvent);
        cache.removeEvent(secondaryEvent);
        assertFalse(cache.getEvents().isEmpty());
        boolean found = false;
        for (final VulnerabilityEvent cachedEvent : cache.getEvents()) {
            if (cachedEvent.getEventKey().equals(secondaryEvent.getEventKey())) {
                found = true;
            }
        }
        assertFalse(found);
    }

    @Test
    public void testRemoveViaKey() throws Exception {
        final VulnerabilityCache cache = createCache(vulnerabilityList);
        cache.addEvent(addEvent);
        cache.addEvent(secondaryEvent);
        cache.removeEvent(secondaryEvent.getEventKey());
        assertFalse(cache.getEvents().isEmpty());
        boolean found = false;
        for (final VulnerabilityEvent cachedEvent : cache.getEvents()) {
            if (cachedEvent.getEventKey().equals(secondaryEvent.getEventKey())) {
                found = true;
            }
        }
        assertFalse(found);
    }

    @Test
    public void testHasEvent() throws Exception {
        final VulnerabilityCache cache = createCache(vulnerabilityList);
        cache.addEvent(addEvent);

        assertTrue(cache.hasEvent(addEvent.getEventKey()));
        assertFalse(cache.hasEvent(secondaryEvent.getEventKey()));
        cache.addEvent(secondaryEvent);
        assertTrue(cache.hasEvent(addEvent.getEventKey()));
        assertTrue(cache.hasEvent(secondaryEvent.getEventKey()));
    }

    @Test
    public void testGetEvent() throws Exception {
        final VulnerabilityCache cache = createCache(vulnerabilityList);
        cache.addEvent(addEvent);
        cache.addEvent(updateEvent);
        cache.addEvent(deletedEvent);

        final Collection<VulnerabilityEvent> eventList = cache.getEvents();
        assertFalse(eventList.isEmpty());
        for (final NotificationEvent<?> event : eventList) {

            final Set<ItemEntry> dataSet = event.getDataSet();
            final ItemEntry componentKey = new ItemEntry(ItemTypeEnum.COMPONENT.name(), EventTestUtil.COMPONENT);
            assertTrue(dataSet.contains(componentKey));

            final ItemEntry versionKey = new ItemEntry("", EventTestUtil.VERSION);
            assertTrue(dataSet.contains(versionKey));
        }
    }
}
